package main

import (
	"bufio"
	"crypto/sha512"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"sync"

	"github.com/Shopify/sarama"
)

// Node is used by json.Unmarshal() to check JSON generated by the instrument.
type Node struct {
	Fn       uint64 `json:"fn,omitempty"`
	Cs       uint64 `json:"cs,omitempty"`
	Ncalls   uint   `json:"ncalls,omitempty"`
	Nsamples uint   `json:"nsamples,omitempty"`
	Callees  []Node `json:"callees,omitempty"`
	CheckSum string `json:"checksum,omitempty"`
}

func gettopic(tf string) string {
	f, err := os.Open(endpoint + tf)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	s, err := bufio.NewReader(f).ReadString('\n')
	if err != nil {
		panic(err)
	}
	return s[:len(s) - 1]
}

func relay(s net.Listener, msg chan sarama.ProducerMessage, sum string, wg *sync.WaitGroup) {
	defer wg.Done()

	conn, err := s.Accept()
	check(err)

	// we send profile data to a dedicated topic
	topic := gettopic("/prof")

	line := bufio.NewScanner(conn)
	for line.Scan() {
		var n Node
		err := json.Unmarshal(line.Bytes(), &n)
		if err != nil {
			//log.Println(string(line.Bytes()))
			panic(err)
		}

		log.Println("wrapper: got", len(line.Bytes()), "B of valid JSON")

		n.CheckSum = sum
		b, err := json.Marshal(n)
		check(err)

		//log.Println(string(b))
		msg <- sarama.ProducerMessage{
			Topic: topic,
			Value: sarama.ByteEncoder(b),
		}
	}
}

// Produce all messages in one spot. When msg is closed, we finish.
func produce(msg chan sarama.ProducerMessage) {
	p, err := connect()
	check(err)
	defer p.Close()

	for m := range msg {
		pt, o, err := p.SendMessage(&m)
		check(err)
		log.Printf("wrapper: produce: pt = %v, o = %v, err = %v\n", pt, o, err)
	}
}

func connect() (sarama.SyncProducer, error) {
	certdir := endpoint + "/cert"
	certpool := x509.NewCertPool()
	pemCerts, err := ioutil.ReadFile(certdir + "/ck_ca")
	dsc := certdir + "/ck_cert"
	dpk := certdir + "/ck_private_key"
	if err == nil {
		certpool.AppendCertsFromPEM(pemCerts)
	}

	cert, err := tls.LoadX509KeyPair(dsc, dpk)
	check(err)

	tc := tls.Config{
		RootCAs:            certpool,
		ClientAuth:         tls.NoClientCert,
		ClientCAs:          nil,
		InsecureSkipVerify: true,
		Certificates:       []tls.Certificate{cert},
	}

	config := sarama.NewConfig()
	config.Producer.Return.Successes = true
	config.Net.TLS.Enable = true
	config.Net.TLS.Config = &tc
	config.ClientID = "ProfileTest"

	broker := func(path string) []string {
		f, err := os.Open(path)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		var broker []string
		s := bufio.NewScanner(f)
		for s.Scan() {
			broker = append(broker, s.Text())
		}
		return broker
	}(endpoint + "/broker")

	return sarama.NewSyncProducer(broker, config)
}

func checksum(path string) string {
	f, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	h := sha512.New512_224()
	if _, err := io.Copy(h, f); err != nil {
		log.Fatal(err)
	}

	hash := h.Sum(nil)
	sum := fmt.Sprintf("%x", hash)
	log.Println("checksum():", path, sum)
	return sum
}

func valid(sum string) bool {
	ep := gettopic("/url") + "/check_releases/" + sum
	fmt.Println("wrapper: release check url:", ep)
	resp, err := http.Get(ep)
	fmt.Println("wrapper: valid: response status:", resp.Status)
	if err != nil {
		log.Fatal(err)
	}

	switch resp.StatusCode {
	case 200:
		return true
	case 404:
		return false
	default:
		log.Fatal("wrapper: valid: got unexpected status ", resp.Status)
	}
	return false
}

// Run a command and report when it exits.
func run(cmd *exec.Cmd, msg chan sarama.ProducerMessage, wg *sync.WaitGroup) {
	defer wg.Done()

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	err := cmd.Start()
	check(err)
	err = cmd.Wait()

	b, e := json.Marshal(err)
	check(e)
	log.Printf(string(b))

	msg <- sarama.ProducerMessage{
		Topic: gettopic("/event"),
		Value: sarama.ByteEncoder(b),
	}
	close(msg)
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func usage() {
	fmt.Printf("usage: %v command [args ...]\n", os.Args[0])
	os.Exit(0)
}

var endpoint string

func main() {
	// Open a socket to communicate with the child command.
	server, err := net.Listen("unix", "socket-"+strconv.Itoa(os.Getpid()))
	check(err)
	defer server.Close()

	sigs := make(chan os.Signal)
	signal.Notify(sigs)
	go func() {
		for s := range sigs {
			log.Println(s)
			server.Close()
			os.Exit(0)
		}
	}()

	endpoint = os.Getenv("AUKLET_ENDPOINT")
	if endpoint == "" {
		panic("empty endpoint")
	}
	args := os.Args
	if len(args) < 2 {
		usage()
	}
	cmd := exec.Command(args[1], args[2:]...)

	cksum := checksum(cmd.Path)
	if !valid(cksum) {
		log.Fatal("wrapper: invalid checksum")
	}

	msg := make(chan sarama.ProducerMessage)
	go produce(msg)

	var wg sync.WaitGroup
	wg.Add(1)
	go relay(server, msg, cksum, &wg)

	wg.Add(1)
	go run(cmd, msg, &wg)
	wg.Wait()
}
