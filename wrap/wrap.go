package main

import (
	"bufio"
	"crypto/rand"
	"crypto/sha512"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math/big"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/Shopify/sarama"
)

// Object represents something that can be sent to the backend. It must have a
// topic and implement a brand() method that fills UUID and checksum fields.
type Object interface {
	topic() string
	brand()
}

func uuid() string {
	x := big.NewInt(2)
	y := big.NewInt(128)
	z := big.NewInt(0)
	i, err := rand.Int(rand.Reader, z.Exp(x, y, z))
	if err != nil {
		log.Panic(err)
	}
	b := i.Bytes()
	return fmt.Sprintf("%x-%x-%x-%x-%x", b[0:4], b[4:6], b[6:8], b[8:10],
		b[10:])
}

func checksum(path string) string {
	f, err := os.Open(path)
	if err != nil {
		log.Panic(err)
	}
	defer f.Close()

	h := sha512.New512_224()
	if _, err := io.Copy(h, f); err != nil {
		log.Panic(err)
	}

	hash := h.Sum(nil)
	sum := fmt.Sprintf("%x", hash)
	//log.Println("checksum():", path, sum)
	return sum
}

// Event contains data pertaining to the termination of a child process.
type Event struct {
	CheckSum string    `json:"checksum"`
	UUID     string    `json:"uuid"`
	Time     time.Time `json:"timestamp"`
	Status   int       `json:"exit_status"`
	Signal   string    `json:"signal,omitempty"`
}

func (e Event) topic() string {
	return gettopic("/event")
}

func (e *Event) brand() {
	e.UUID = uuid()
	e.CheckSum = cksum
}

func event(state *os.ProcessState) *Event {
	ws, ok := state.Sys().(syscall.WaitStatus)
	if !ok {
		log.Print("expected type syscall.WaitStatus; non-POSIX system?")
		return nil
	}
	return &Event{
		Time:   time.Now(),
		Status: ws.ExitStatus(),
		Signal: func() string {
			if ws.Signaled() {
				return ws.Signal().String()
			}
			return ""
		}(),
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func usage() {
	log.Fatalf("usage: %v command [args ...]\n", os.Args[0])
}

func run(obj chan Object, cmd *exec.Cmd) {
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	log.Print("starting child")
	err := cmd.Start()
	if err != nil {
		panic(err)
	}

	done := make(chan struct{})
	sig := make(chan os.Signal)
	signal.Notify(sig, syscall.SIGINT)

	go func() {
		cmd.Wait()
		obj <- event(cmd.ProcessState)
		done <- struct{}{}
	}()

	for {
		select {
		case s := <-sig:
			log.Print("relaying signal: ", s)
			cmd.Process.Signal(s)
		case <-done:
			log.Print("child exited")
			return
		}
	}
}

// Node is used by json.Unmarshal() to check JSON generated by the instrument.
type Node struct {
	CheckSum string `json:"checksum,omitempty"`
	UUID     string `json:"uuid,omitempty"`
	Fn       uint64 `json:"fn,omitempty"`
	Cs       uint64 `json:"cs,omitempty"`
	Ncalls   uint   `json:"ncalls,omitempty"`
	Nsamples uint   `json:"nsamples,omitempty"`
	Callees  []Node `json:"callees,omitempty"`
}

func (n Node) topic() string {
	return gettopic("/prof")
}

func (n *Node) brand() {
	n.UUID = uuid()
	n.CheckSum = cksum
}

func gettopic(tf string) string {
	f, err := os.Open(endpoint + tf)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	s, err := bufio.NewReader(f).ReadString('\n')
	if err != nil {
		panic(err)
	}
	return s[:len(s)-1]
}

func logs(logger io.Writer) (func(), error) {
	l, err := net.Listen("unixpacket", "log-"+strconv.Itoa(os.Getpid()))
	if err != nil {
		return func() {}, err
	}
	log.Print("logs socket opened")

	done := make(chan error)
	go func() {
		c, err := l.Accept()
		if err != nil {
			done <- err
		}
		log.Print("logs connection accepted")

		t := io.TeeReader(c, logger)
		_, err = ioutil.ReadAll(t)
		done <- err
	}()

	return func() {
		if err := <-done; err != nil {
			log.Print(err)
		}
		log.Print("closing logs socket")
		l.Close()
	}, nil
}

func relay(obj chan Object) (func(), error) {
	s, err := net.Listen("unix", "data-"+strconv.Itoa(os.Getpid()))
	if err != nil {
		return func() {}, err
	}
	log.Print("data socket opened")

	done := make(chan error)

	go func() {
		c, err := s.Accept()
		if err != nil {
			done <- err
		}
		log.Print("data connection accepted")
		line := bufio.NewScanner(c)

		// quits on EOF
		for line.Scan() {
			var n Node
			err := json.Unmarshal(line.Bytes(), &n)
			if err != nil {
				done <- err
				return
			}
			obj <- &n
		}
		log.Print("data socket EOF")
		done <- nil
	}()

	return func() {
		// wait for socket relay to finish
		if err := <-done; err != nil {
			log.Print(err)
		}
		log.Print("closing data socket")
		s.Close()
	}, nil
}

func connect() (sarama.SyncProducer, error) {
	certdir := endpoint + "/cert"
	certpool := x509.NewCertPool()
	pemCerts, err := ioutil.ReadFile(certdir + "/ck_ca")
	dsc := certdir + "/ck_cert"
	dpk := certdir + "/ck_private_key"
	if err == nil {
		certpool.AppendCertsFromPEM(pemCerts)
	}

	cert, err := tls.LoadX509KeyPair(dsc, dpk)
	check(err)

	tc := tls.Config{
		RootCAs:            certpool,
		ClientAuth:         tls.NoClientCert,
		ClientCAs:          nil,
		InsecureSkipVerify: true,
		Certificates:       []tls.Certificate{cert},
	}

	config := sarama.NewConfig()
	config.Producer.Return.Successes = true
	config.Net.TLS.Enable = true
	config.Net.TLS.Config = &tc
	config.ClientID = "ProfileTest"

	broker := func(path string) []string {
		f, err := os.Open(path)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		var broker []string
		s := bufio.NewScanner(f)
		for s.Scan() {
			broker = append(broker, s.Text())
		}
		return broker
	}(endpoint + "/broker")

	return sarama.NewSyncProducer(broker, config)
}

func produce(obj chan Object) (func(), error) {
	// Create a Kafka producer with the desired config
	p, err := connect()
	if err != nil {
		// bad config or closed client
		return func() {}, err
	}
	log.Println("kafka producer connected")

	done := make(chan error)
	go func() {
		// receive Kafka-bound objects from clients
		for o := range obj {
			o.brand()
			b, err := json.Marshal(o)
			if err != nil {
				done <- err
				return
			}
			//log.Printf("producer got %v bytes: %v", len(b), string(b))
			log.Printf("producer got %v bytes", len(b))
			_, _, err = p.SendMessage(&sarama.ProducerMessage{
				Topic: o.topic(),
				Value: sarama.ByteEncoder(b),
			})
			if err != nil {
				done <- err
				return
			}
		}
		done <- nil
	}()

	return func() {
		// wait for kafka producer to finish
		if err := <-done; err != nil {
			log.Print(err)
		}
		log.Print("closing kafka producer")
		p.Close()
	}, nil
}

var cksum string

func valid(sum string) bool {
	ep := gettopic("/url") + "/check_releases/" + sum
	//log.Println("wrapper: release check url:", ep)
	resp, err := http.Get(ep)
	if err != nil {
		log.Panic(err)
	}
	//log.Println("wrapper: valid: response status:", resp.Status)

	switch resp.StatusCode {
	case 200:
		return true
	case 404:
		return false
	default:
		log.Panic("wrapper: valid: got unexpected status ", resp.Status)
	}
	return false
}

var endpoint string

func main() {
	logger := os.Stdout
	log.SetOutput(logger)

	endpoint = os.Getenv("AUKLET_ENDPOINT")
	if endpoint == "" {
		log.Fatal("empty envar AUKLET_ENDPOINT")
	}

	args := os.Args
	if len(args) < 2 {
		usage()
	}
	cmd := exec.Command(args[1], args[2:]...)

	cksum = checksum(cmd.Path)
	if !valid(cksum) {
		//log.Fatal("invalid checksum: ", cksum)
		log.Print("invalid checksum: ", cksum)
	}

	obj := make(chan Object)

	wprod, err := produce(obj)
	check(err)
	defer wprod()

	wrelay, err := relay(obj)
	check(err)
	defer wrelay()

	lc, err := logs(logger)
	check(err)
	defer lc()

	run(obj, cmd)
	close(obj)
}
