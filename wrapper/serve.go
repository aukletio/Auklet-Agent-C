package main

import (
	"bufio"
	"encoding/json"
	"log"
	"net"
	"sync"

	"github.com/Shopify/sarama"
)

// Node is used by json.Unmarshal() to check JSON generated by the instrument.
type Node struct {
	Fn       uint64 `json:"fn,omitempty"`
	Cs       uint64 `json:"cs,omitempty"`
	Ncalls   uint   `json:"ncalls,omitempty"`
	Nsamples uint   `json:"nsamples,omitempty"`
	//Callees  []Node `json:"callees,omitempty"`
	Callees  []Node `json:"callees"`
	CheckSum string `json:"checksum,omitempty"`
}

func relay(s net.Listener, msg chan sarama.ProducerMessage, sum string, wg *sync.WaitGroup) {
	defer wg.Done()

	conn, err := s.Accept()
	check(err)

	topic := map[string]string{
		"qa":          "6eyc-profiler",
		"new-staging": "f9l0-profiler",
		"prod":        "f9en-profiler",
	}
	line := bufio.NewScanner(conn)
	for line.Scan() {
		var n Node
		err := json.Unmarshal(line.Bytes(), &n)
		if err != nil {
			panic(err)
		}

		log.Println("wrapper: got", len(line.Bytes()), "B of valid JSON")

		n.CheckSum = sum
		b, err := json.Marshal(n)
		check(err)

		msg <- sarama.ProducerMessage{
			Topic: topic["new-staging"],
			Value: sarama.ByteEncoder(b),
		}
		log.Println(string(b))
	}
}

// Produce all messages in one spot. When msg is closed, we finish.
func produce(msg chan sarama.ProducerMessage) {
	p, err := connect()
	check(err)
	defer p.Close()

	for m := range msg {
		pt, o, err := p.SendMessage(&m)
		check(err)
		log.Printf("wrapper: produce: pt = %v, o = %v, err = %v\n", pt, o, err)
	}
}
